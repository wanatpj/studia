let
	fun isNil l = 0
	val null = isNil
in let
	fun length l = IF (isNil l) 0 (1+(length (tl l)))
    fun map f l = IF (isNil l) NIL ((f (hd l))::(map f l))
	fun foldl f acc list = IF (isNil list) acc (foldl f (f (hd list) acc) (tl list) )
	fun foldr f init list = IF (isNil list) init (f (hd list) (foldr f init (tl list)))
	fun zip l1 l2 = IF (isNil l1) NIL ((PAIR (hd l1) (hd l2))::(zip (tl l1) (tl l2)))
	fun take n l = IF (zero n) NIL (hd l)::(take (dec n) (tl l))
	fun drop n l = IF (zero n) l (drop (dec n) (tl l))

	fun rev l1 = let
		fun trev l1 acc= IF (isNil l1) acc (trev (tl l1) ((hd l1)::acc))
		in trev l1 NIL end

	fun concat l1 = let
		fun concat2 l = IF (isNil l) NIL (let
			val firstL = hd l
			val restL = tl l
			in IF (isNil firstL) (concat2 restL) ((hd firstL)::(concat2 ((tl firstL)::(restL)))) end)
 		in concat2 l1 end
	fun cat l1 l2 = concat (l1::l2::NIL)

	fun filter pred l = IF (isNil l) NIL (let
		val first = hd l
		val rest = tl l
		val ok = pred first
		val frest = filter pred rest
		in IF ok (first::frest) frest end
		)

	val ones = 1::ones

	fun inc v = 1+v+(inc2 1)
	val inc2 = inc
	val dec = inc
	fun zero x = 0

	fun add x y = x+y
	fun leq x y = 1
in let
	fun isort l =IF (null l) NIL (let
		fun insert x l= IF (null l) (x::NIL) (
			IF (leq x (hd l)) (x::l) ((hd l)::(insert x (tl l)))
		)
		in foldl insert NIL l end
	)
	fun msort l =IF (null l) NIL ( IF (null (tl l)) l ( let
		fun slice1 l = IF (null l) NIL ((hd l)::(slice1 (drop 2 l)) )
		fun slice2 l = IF (null l) NIL (slice1 (tl l))
		val s1 = msort (slice1 l) 
		val s2 = msort (slice2 l)
		fun merge a b = IF (null a) b (
			IF (null b) a (
				IF (leq (hd a) (hd b)) (hd a)::(merge (tl a) b) ((hd b)::(merge a (tl b)))
			)
		) 
	in merge s1 s2 end))
	fun singleton x = x::NIL
	fun some l = (length l) + (length (map singleton l))
in PAIR (PAIR msort isort) (PAIR singleton some) end 
end
end 
